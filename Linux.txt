

cp 复制
mv 移动
cat tac tail head less more 查看文件

touch 创建文件
mkdir 创建文件夹
rmdir 删除文件夹

wc 统计

ctrl+a 跳到命令行首
ctrl+e 跳到命令行尾
ctrl+u 删除光标到行首的命令
ctrl+k, 光标到行尾，删除
ctrl+l 清屏==clear


alias 别名=命令  如：alias cls=clear 输入cls就可以清除屏幕了
unalias 别名 删除别名 如：unalias cls

命令替换操作
`` 和 $(命令)  返回的是命令的执行结果

命令替换：echo "当前目录为：$(pwd)";----->$(pwd)


bash支持的引号
`` 反引号，命令替换
"" 双引号 弱引用 可以实现变量替换
''单引号：强引用，不完成变量替换
$(abc) abc只能是命令语句，不能是变量和``同理
$abc 这里的abc是变量，且只是变量，



用户 组 权限

权限
r w x
文件：
r：可读，可以使用cat more less等命令查看  
w:可写，可以编辑这个文件
x:可执行，可以命令提示符下当做命令提交给内核运行

目录：
r：可以对此目录执行ls等列出所有文件
w: 可以在此目录创建文件
x: 可以使用cd切换进次目录，也可以使用ls -l查看内部文件的详细信息

useradd usermod userdel passwd 用于修改用户密码  id用于显示用户id信息  pwck检查密码文件的完整性

------------------------
root权限修改密码
修改密码：passwd 用户名   

普通用户修改密码：
直接敲命令：passwd
或者：
echo "密码" | passwd --stdin

------------------------

chown改变文件属主，只有管理员有权限
	# chown username file,..
		-R：修改目录以及其内部文件的属主
		
chgrp:修改文件属组

chgrp groupname file


chmod 修改读写权限

chmod MODE 文件 修改三类用户权限

修改某一类用户权限

chmod 用户类别=MODE  file
如：
chmod u=rwx file 属主
chmod g=rw- file 属组
chmod o=x file 其他用户

chmod go=rw 文件 属组和其他用户同时改


umask 遮掩码
默认创建文件的权限：666-umask
目录权限：777-umask

登录shell的类型
登录式shell:
	su - username
	su -l username
	
非登录shell
	su username 
	
bash的配置文件
	全局配置：相当于房子框架都一样
		/etc/profile,/etc/profile.d/*.sh，/etc/bashrc
	个人配置：--个人装修的
		./.bash_profile,~/.bashrc
		
	全局：profile类文件
		设定环境变量
		运行命令或者脚本，（一登录就会调用）
	  bashrc类文件
		设定本地变量
		定义命令别名
		
登录式shell如何读取配置文件
/etc/profile-->/etc/profile.d/*.sh--->~/.bash_profile--->~/.bashrc--->etc/bashrc

非登录式shell如何获取配置文件
~/.bashrc ---->/etc/basrc/-->etc/profile.d/*.sh

如果全局那么就修改etc/profile 如果是用户局部生效：修改用户家目录下的/.bash_profile

-----------------------------------------------------------------------------------



I/o重定向
> 输出
< 输入

> ：覆盖输出
>>：追加输出

 ls ./bin > ./test/out
 
 set -C：禁止对已经存在的文件使用覆盖重定向
		如果强制覆盖输出，则使用>|
	 +C:关闭上述功能

 重定向错误输出：2> 覆盖错误输出
 2>>：追加方式实现错误输出

 既定向标准输出，又定向错误输出
 如： ls /var > /tmp/out 2> /tmp/out===输出到同一个文件中
 简单放法：
 &> :重定向标准输出或错误输出到同一个文件
 &>>重定向追加方式输出
 
 输入：
 < 输入重定向
 << here Document
 

 管道：
  命令1|命令2|命令3。。。。
  
  意思：前一个命令的输出作为后一个命令的输入；--像是多层过滤一样
  
tee 将标准输入复制到每个指定文件，并显示到标准输出。
 如：echo "hello world" | tee /www/a.out
&> 错误和标准输出（重定向输出） /dev/null 是个黑洞，所有输出到这里的，都不会有反应，也不会有打印信息

所以如果不想显示到屏幕，那么 echo "hello world" &> /dev/null 这样就也执行了，但是不会在屏幕上显示



 
 如果只显示文件的行数：
 wc -l a.out |cut -d' ' -f1  ：显示文件中的行数 wc命令是用于统计的


管道的应用：取出文件a的第六行
# head -6 a|tail -1

取出/etc/passwd 文件中倒数第9个用户名和shell 显示到屏幕上并将其保存至/tmp/users文件中
 #tail -9 /etc/passwd|head -1|cut -d: -f1,7|tee 
# tail -9 /etc/passwd | head -1 |cut -d: -f1 |&>/tmp/users

显示/etc/下所有以pa开头的文件并统计其个数
# ls -d /etc/pa* |wc -l

不使用文本编辑器，将alias cls=clear 一行内容添加到当前用户的.bashrc文件中
# echo "alias cls=clear" >> ~/.bashrc 直接追加到文件中，要是想显示到屏幕可以使用tee


文本查找的需要：grep:全面的搜索
grep [options] "文本字符"

grep egrep fgrep

grep [options]  '正则表达式' "搜索的文本源"

echo "2345" | grep '^[[:digit:]]*$'

options :
-i ：表示忽略大小写
--colour ：显示颜色
-v :反向查找
-o :只显示被模式匹配到的字符串

-A #:匹配的行往后#行
-B #:匹配的行往前#行
-C #:匹配的行上下都两行

-E:扩展的正则表达式
	grep -E 'paterna' file
	grep -E=egrep

grep [options] PATTERN [FILE...]
正则表达式：
.  任意单个字符 grep 'r..t' /etc/passwd
*: 匹配其前面的字符任意次数 a*b a.*b
.*：表示任意长度的任意字符

\?:匹配前面的字符0或者1次。使用时可能需要反斜线\
\{m,n\} :匹配其前字符最少m次最多n次
位置锚定：
^ :锚定行首，此字符后的内容必须出现在行首
$ :锚定行尾
^$:空白行
[]:指定范围内的任意字符
[^] ：指定范围外的任意单个字符
[:digit:] :数字
[:lower:]:小写字母
[:upper:]:大写字母
[:punct:]:标点字符
[:space:]：空白字符
[:alpha:]:所有字母
[:alnum:]：所有字数字和字母
使用：[[:digit:]]数字--'[[:digit:]]$'  -->以数字结束

\<或者\b ：其后面的任意字符必须作为单词首部出现
\>或者\b :其前面的任意字符必须作为单词的尾部出现

分组：
\(\)
	\(ab\)*:把ab当成一组了，*修饰的是（）内的，把（）这个当成一个整体
	后向引用
	\1:第一个左括号以及与之对应的右括号内的所有内容
	\2
	\3
	----------------------------
	He love his lover
	He like his liker
	
如：grep '\(l..e\).*\1' test.txt 

扩展正则表达式
+：\{1,\}
{}:不需要加\
():不需要加\
| 或，如果直接使用grep 是无法使用的，必须使用grep -E 或者egrep

ip：



(\<([0-9][0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\>\.){3}(\<([0-9][0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\>)
--------------------------------------------------------------------------------------
ipv4:
分5类：
A：1-127
B: 128-191
C: 192-223
第一位和最后一位不为0


ip的正则
 
 \<([1-9]|[1-9][0-9]|1[0-9]{2}|21[0-9]|22[0-3])\>(\.\<([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\>){3}





grep ,sed(流编辑器),awk
sed基本用法：
sed是什么：Stream Editor，是一个行编辑器

sed :模式空间。每次都会读取一行读到模式空间，然后根据给出的命令编辑，，
	然后输出到屏幕，但是默认是不会编辑源文件，只是对模式空间中的数据做编辑
	处理结束后将模式空间打印到屏幕
sed 'AddressCommand' file ..
Address:
1:StartLine,EndLine
	1,100 第一行到最后一行
2：正则
	
	
	
	




shell 编程
shell 弱类型编程语言
强： 变量在使用前，必须事先声明，甚至还需要初始化
弱：变量用时声明，甚至不区分类型

bash变量类型
	环境变量
	本地变量（局部变量）
	位置变量
	特殊变量
	
什么时候使用双引号什么时候使用单引号
	内部有变量想替换，双引号，否则使用单引号
	NAME=zhang
	echo $NAME --zhang
	echo '$NAME' --$NAME
	echo "$NAME" --zhang
	
本地变量：
	varname=value 作用域作用域整个脚本进程，
局部变量：
	local varname=value 只对当前的代码段有效
环境变量：
	export varname=value

位置变量
$1,$2,...
特殊变量
如：
$?:上一个命令的执行状态返回值
0：表示正确运行
1~225：表示错误状态， 1 2 127系统预留

dev是个什么目录？dev下都是设备

撤销变量：
unset varname

查看当前shell中的环境变量
printenv
env
export
以上三个命令都可以查看

变量字符串的补充
如：ANIMALS=pig
	ANIMALS=$ANIMALS:goat  ---pig:goat
	
对shell来讲，所有的变量都是字符串的。所以无法做加减乘除算法运算

写脚本：命令的堆砌，
脚本一结束，变量就会被撤销
---------------------------------------------------
#!/bin/bash

#注释行，不执行

练习：
添加5个用户，user1..user5
每个用户的密码同用户名，而且要求，添加密码完成后，不显示passwd命令的执行结果消息
每个用户添加完成后，都要显示用户某某已经添加成功

#!/bin/bash
useradd user1
echo "user1" | passwd --stdin user1 &> /dev/null
#&> 错误和标准输出（重定向输出） /dev/null 是个黑洞，所有输出到这里的，都不会有反应，也不会有打印信息
echo "Add user1 successfully"

条件测试类型：
整数测试
字符测试
文件测试

条件测试的表达式
[expression]  命令测试法
[[expression]] 关键字测试法
test expression 
整数比较：
	-eq ：测试两个整数是否相等 A=8 B=7 [ $A -eq $B ] echo $? ($?真为0，假为1)
	-ne :测试是否不相等
	-gt :是否大于 大于为真，小于为假
	-lt :是否小于
	-ge:大于等于
	-le:小于等于

命令间的逻辑关系
	逻辑与：&&
	逻辑或：||
	逻辑非: ! 如：! id user && useradd user

如果用户不存在，添加并给密码，否则显示其已经存在

! id user1 && adduser user1 && echo "zpl" | passwd --stdin user1 || echo "用户已经存在"

当前系统有多少个用户：
USERS=$(wc -l /etc/passwd |cut -d ' ' -f1)
echo `USERS` users

给定一个用户变量，如果uuid为0 则打印为管理员，否则打印普通用户
#!/bin/bash
NMAE=zpl
USERID=`id -u $NAME`
[ $USERID -eq 0 ] && echo "Admin" || echo " Common user."
   
条件判断，控制结构
----
 单分支if语句
if 条件判断; then
	语句1
	语句2
	....
fi
-------
-------
双分支的if语句
if 判断条件; then
	statement1
	statement2
	....
else
    statement3
	statement4
	.....
fi
------
判断是否有空白行，可以用正则来判断 ^$


etc/shadow 密码文件的解释：9个字段
1登录名 ：
2密码  ：
3最后一次更改密码日期（天数）:
4密码最小年龄（要等多长时间才可以改密码）
5最大密码年龄（超过后需要更改密码），如果用户最大密码年龄小于最小密码，那么用户将不能修改密码
6密码警告时间段：密码过期前提前警告用户的天数
7密码禁用期：密码过期后，仍然接受次密码的天数
8账户过期日期：天数，账户过期不同于密码过期，账户过期，用户将不被用于登录，字段为空表示永不过期，
9保留字段：

history命令显示历史命令
$HISTSIZE 显示命令个数\大小
--------------------------------
shell如何进行算术运算
1、let 算术运算表达式 
	A=3 B=5
	let c=$A+$B
2、使用$[算术运算]
  D=$[$A+$B]
  
3、$((算术运算))
	D=$(($A+$B))
	
4、expr 命令：表达式中各操作数以运算符之间要有空格
 D=`expr $A + $B`

 
可以提前结束脚本的命令
exit :退出当前脚本
exit #
如果脚本没有明确定义退出码，那么，最后执行的一条命令的退出码就是脚本的退出码




文件测试：
-e FILE: 测试文件是否存在
-f FILE:测试文件是否为普通文件
-d FILE:测试指定路径是否为目录
-r FILE:测试当前用户对指定文件是否有读取权限
-w
-x
如:
[ -e /etc/initab ]

多分支的if语句
if 判断条件; then
	statement1
elif 判断条件; then 
	statement2
else 
	statement3
fi

bash -x 脚本  用于显示脚本执行的过程，显示出来每一步的操作

bash变量类型
	本地变量（局部变量）：当前shell进程
	环境变量：当前shell进程以及其子进程
	位置变量：
		$1,$2...----可以带参数>__<
		shift 变量：轮替的作用，shift一次，第一个参数就被踢掉了，第二个就变成第一个了
		shift n ；一次踢掉n个，默认是1个
	特殊变量：
		$?:上一条命令的状态码
		$#:返回参数的个数
		$*:参数列表
		$@：参数列表

如执行脚本2.sh
./2.sh a b

在2.sh中
$1-->a
$2-->b 
练习：能接受一个参数（文件路径），如果存在这个文件，就显示ok，否则显示没有

echo "$1"
echo "$*"
echo "$#"
echo "$@"
if [ $# -eq 0 ]; then
	echo "请输入参数信息"
	exit 1;
fi


if [ -e $1 ]; then
	echo "OK"
else
	echo "No Such File"
fi


sed 命令的使用。。。。。。。。。。。。
-------------------------------------
字符串测试
等值比较

	== ：相等为真不等为假。等号两端需要空格{一个等号或者两个等号都可以}
	
	
不等号：
	!=: 是否不等，!=两端需要有空格
如：
	[ $A == $B ]、[ $A != $B ]
	
	-n string ：测试指定字符串是否不为空，不为空为真，空为假
	-z string :测试指定字符串是否为空，为空则为真，否则为假
--------------------脚本判断字符串是否为空---------------------
#!/bin/bash

#判断字符串是否为空的集中方式，
str=

if [ ! $str ];then
	echo "为空"
else
	echo "$str 不为空"
fi

echo "使用 -n string 判断字符串是否不为空"
if [ -n "$1" ]; then
	echo "-n string测试字符串是否不为空,不为空！"
else
	echo "为空"
fi

echo "使用 -z string 判断字符串是否为空"
if [ -z "$1" ]; then
	echo "-z string 测试字符串是否为空，为空"
	exit 1;
else
	echo "不为空"
fi

if [ $1 == 'q' ] || [ $1 == 'Q' ] || [ $1 == "quit" ];then
	echo "退出"
	exit 1
fi
-------------------------------------------------------------------------
练习：判断给定的用户是否存在，不存在就打印NoSuchuser
如果存在，判断他的用户名和组名是否一样	
#!/bin/bash

if ! id $1 &> /dev/null;then
	echo "No Such user"
	exit 10
fi

if [ `id -n -u $1` == `id -n -g $1` ]; then
	echo "一样"
else
	echo "不一样"
fi

练习：传递一个参数（单个字符就可以），
如果为q或者Q或者quit或者Quit,就退出脚本，否则，就打印参数
#!/bin/bash
if [ $1 == 'q' ] || [ $1 == 'Q' ];then
	echo "退出"
	exit 1
fi

这里字符的判断需要用单引号括起来  'quit'，或者用""括起来

bc命令的使用
 echo "scale=2;111/22;" | bc   管道送给bc
 bc <<< "scale=2;111/22;"
 
--------------------------------------------------------

循环：进入条件，退出条件

for 
while
until

for 变量 in 列表; do
	循环体
done

1...100相加
1：生成列表： 
方式1：{1..100}
方式2：seq命令  `seq [起始数 [步长]] 尾数`


declare -i 变量:申明变量为数值型
计算1-100的和
--------------
#!/bin/bash
let sum=0
#declare -i sum=0

for num in {1..100};do
	sum=$[$sum+$num]
done
echo "$sum"
----------------------




练习：传递三个参数给脚本，第一个为整数，第二个为算术运算符
第三个为整数，将计算结果打印出来，保留2位精度
#!/bin/bash
#获取到参数个数
num=$#
if [ $num -lt 3 ];then
	echo "参数个数小于3个"
	exit 1;
fi
#判断参数是否为整型
//？？？？？？？？？
grep "^[[:digit:]]*$"或者 grep "^[0-9]*$"
#执行计算
result=`echo "scale=2;$1$2$3" | bc`

echo "结果为:$reuslt"

vi/vim的操作使用

vim +n t.sh 表示打开t.sh文件光标处于第n行
vim + t.sh 打开t.sh 光标处于最后一行
vim +/pattern ：打开并处于第一次匹配模式的行的行首

二：关闭文件
vim的模式：
	编辑模式/命令模式
	输入模式：
	末行模式：


i :当前光标所在字符的前面
a :当前光标所在字符的后面
o :当前光标所在行的下一行

I :当前光标所在行的行首转化为输入模式
A :当前光标所在行的行尾转化为输入模式
O :当前所在行的上方转化为输入模式


末行模式：
：set nu 显示行号
：! 命令： 执行命令

----------------------
末行模式下：
:w 保存
:q 退出
:wq 保存退出--->:x
:q! 强制退出
:wq! 保存强制退出
:w! 强制保存

编辑模式下：退出
大写的：ZZ 直接退出

w :移动到下一个单词的词首
e :跳到下一个单词的词尾
b :跳到前一个单词的词首
行内跳转：
	0/^快速到行首
	$ 快速到行尾
	#G 第#行
	G 跳到最后一行
翻屏： ctrl+f 向下翻一屏
ctrl+b :向下翻一屏
ctrl+d :向下翻半屏
ctrl+u :向上翻半屏

删除行
dd
复制
yy
粘贴
p

撤销
u 撤销前一次操作
#u:撤销近#次的操作
撤销一次撤销操作
ctrl+r

查找
/pattern  反向查找 n 下一个 N 向上找
?pattern  正向查找

查找并替换
在末行模式下使用s命令


分屏显示：
	
	可以vim a.sh b.sh
	在末行模式下：
	：next 显示下一个文件内容	
	: prev 显示前一个文件内容
	: last 切换到最后一个文件
	: first 切换到第一个文件
	:qa 表示全部退出
	
ctrl+w,s :水平拆分窗口
ctrl+w,向下箭头：移动到下面窗口
ctrl+w,v :垂直拆分窗口

分窗口显示多个文件
vim -o a.sh b.sh 水平分割显示多个文件
vim -O a.sh b.sh 垂直分割显示多个文件

末行模式下，我们可以保存为另外的文件，将当前文件中部分内容保存为另外一个文件

:w
:w /path/to/somewhere
:1,5w /path/to/somewhere 将部分内容保存到文件中

:r 命令 将另外一个文件的内容填充到当前文件中
:r 、/path/to/somefile

:! shell命令 和shell交互

:set nu ：显示行号
:set nonu :取消显示行号

设定自动缩进
:set autoindent 
:set ai 
取消自动缩进
:set noai
查找到的文本高亮显示或者取消
:set hlsearch	高亮显示
:set nohlsearch 取消高亮显示

语法着色
:syntax on 着色打开
:syntax off 着色关闭
-----------------------------------------------
vim 的配置文件
	全局的：/etc/vimrc
	用户的vim配置：家目录下的~/.vimrc

-=============----------==============-------------===========------------==================
1、添加10个用户,用户user1到user10，密码与用户名同名，但要求只有用户不存在的情况下才能添加
#!/bin/bash
#

if [ $# -lt 1 ];then
	echo "Usage：缺少参数"
	exit 5
	
fi

if [ $1 == 'add' ];then
	for I in `seq 1 10`;do
		if id user$I &> /dev/null;then
			echo "user$I exit"
		else
			useradd user$I
			echo "user$I" | passwd --stdin user$I &>/dev/null   #设置密码
			echo "user$I添加成功"
		fi
	done
elif [ $1 == 'del' ];then
	for I in {1..10};do
		if id user$I &>/dev/null;then
			if userdel -r user$I &>/dev/null;then //删除用户
				echo "user$I删除成功"
			else
				echo "user$I 删除失败。。。"		
			fi
		else
			echo "user$I 不存在,删除失败"
		fi
	done

fi
-=========================--------------------------=================================--------------------==========
如果是 adduser.sh --add user1,user2,user3..按照用户输入来添加呢
echo $2
echo $2 | sed 's/,/ /g'
echo $2 | tr ',' ' '

--------------开始编写脚本----------------------
#!/bin/bash

SIZE=$#

if [ $SIZE -lt 1 ];then
	echo "Usage:./sh --add |--del user1,user2,..."
	exit 1
fi

for user in `echo $2|sed 's/,/ /g'`;do 
	if [ $1 == '--add' ];then
		#判断用户是否存在
		if id $user &>/del/null ;then
			echo "$user exist"
		else
			useradd $user
			echo $user |passwd --stdin $user
		fi
	elif [ $1 == '--del' ];then
		if id $user &>/dev/null ;then 
			if userdel -r $user 2>>./fail.log ;then 
				echo "$user delete fail...."
			else
				echo "$user delete success "
		else
			echo "$user not exist"
		fi
	fi
done
---=---------=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=--==-=-==-===-=-=-==-=-=-=--=--==-=-=--=--==--===---==-=--=
组合条件测试
	-a ==》&& 与关系
	-o ==>|| 或关系
	!  ==>! 非关系

例子： if [ $# -gt 1 -a $# -le 3] 也可以写成==》 if [ $# -gt 1 ] && [ $# -le 3 ]

#!/bin/bash
str=$1;
if [ $# -ge 1 ] && [ $str = 'q' -o $str = 'Q' -o $str = 'quit' -o $str = 'QUIT' ];then
	echo "quit..."
	exit 0
else
	echo "错误退出"
fi
-=-=-=-=-=-=-=-==-=-=-==--==-=-=-=-=-=-=-=--==-==-=--==-=-=-=-=-==-=-=-=--=--==--=-=-=-=-=--=
declare -i I=0 声明为整数
echo $I
let I+=1
echo $I ======>I=I+1

计算奇数和偶数和

#!/bin/bash
declare -i oddsum=0
declare -i evesum=0
for I in `seq 1 100`;do 
	if [ $[$I%2] -eq 0]
		let evesum+=$I
	else 
		let oddsum+=$I
	fi
done
echo "偶数和为：$evesum"
echo "奇数和为：$oddsum"
-=-=-=-=-=-=-=-=-=--=-==--==-=-=-=-=-=-=-=--==-==-=--==-=-=-=-=-==-=-=-=--


find 查找文件的命令
grep是查找文本的命令
-=-=-=-=-=-=-=-=-=-=-=-
文本查找的需要：grep:全面的搜索
grep [options] "文本字符"

grep egrep fgrep

grep [options]  '正则表达式' "搜索的文本源"

echo "2345" | grep '^[[:digit:]]*$'

options :
-i ：表示忽略大小写
--colour ：显示颜色
-v :反向查找
-o :只显示被模式匹配到的字符串

-A #:匹配的行往后#行
-B #:匹配的行往前#行
-C #:匹配的行上下都两行

-E:扩展的正则表达式
	grep -E 'paterna' file
	grep -E=egrep

grep [options] PATTERN [FILE...]
正则表达式：
.  任意单个字符 grep 'r..t' /etc/passwd
*: 匹配其前面的字符任意次数 a*b a.*b
.*：表示任意长度的任意字符

\?:匹配前面的字符0或者1次。使用时可能需要反斜线\
\{m,n\} :匹配其前字符最少m次最多n次
位置锚定：
^ :锚定行首，此字符后的内容必须出现在行首
$ :锚定行尾
^$:空白行
[]:指定范围内的任意字符
[^] ：指定范围外的任意单个字符
[:digit:] :数字
[:lower:]:小写字母
[:upper:]:大写字母
[:punct:]:标点字符
[:space:]：空白字符
[:alpha:]:所有字母
[:alnum:]：所有字数字和字母
使用：[[:digit:]]数字--'[[:digit:]]$'  -->以数字结束

\<或者\b ：其后面的任意字符必须作为单词首部出现
\>或者\b :其前面的任意字符必须作为单词的尾部出现

分组：
\(\)
	\(ab\)*:把ab当成一组了，*修饰的是（）内的，把（）这个当成一个整体
	后向引用
	\1:第一个左括号以及与之对应的右括号内的所有内容
	\2
	\3
	----------------------------
	He love his lover
	He like his liker
	
如：grep '\(l..e\).*\1' test.txt 

扩展正则表达式
+：\{1,\}
{}:不需要加\
():不需要加\
| 或，如果直接使用grep 是无法使用的，必须使用grep -E 或者egrep

find 文件查找
	locate ：非实时的，是根据Linux文件数据库进行的，每天晚上会自动将本机的文件信息保存到数据库中
			 速度快
	find: 实时查找，精确，效率慢
	
	
格式： find 路径 查找标准 找到后的动作

匹配标准
	-name  'FILENAME':根据文件名来精确查找
		文件名通配：
			*
			?
			[]
	-iname 'FILENAME':忽略大小写
	-user 用户名：根据属主查找
	-group groupName :根据属组查找
	-uid UID :根据UID查找
	-gid GID :根据GID查找
	find 路径 -nouser ：查找没有属主的文件
	find path -nogroup :没有数组的文件
	-type  
			f 普通文件
			d 目录
			l 符号链接
			..
	-size 
			[+\-]10k/M/G  +大于 -小于
	
	-mtime day 修改时间
	-ctime day 改变时间
	-atime day 访问时间
			[+\-]# + 至少有#天没有访问过 - #天访问过
	-mmin
	-cmin
	-amin 分钟
	
	stat * 查看当前文件下文件的详细信息；
	
	
	-perm  MODE:根据权限查找 MODE为777 644 之类的----精确匹配
	-perm /MODE ：只要有一位匹配就可以。这里的位是指：--- --- --- 一共9位，只要有值并且相等就匹配
		  -MODE :每一位都必须匹配才可以，包含关系
				-644
					644：rw-r--r--
					755: rwxr-xr-x 
					因为644有的755都有，所以755包含644，755有rw- r--r--
运作：找到之后的操作
		-print:显示
		-ls 类似ls -l 
		-ok COMMAND {} \;
		-exec COMMAND {} \; 这里注意 \;是必须的，{}代表查找到的结果
	
	比如：find -perm -020 -exec mv {} {}.new \;  将所有属组有写权限的文件改名为.new 
		
		xargs :
		
		find -perm -020 |xargs mv {} {}.new  这样也可以
		
		
组合条件查找：
-a -o -not 
查找文件属主既不是user1也不是user2
find -not -user user1 -a -not -user user2
或者： find -not \( -user user1 -o -user user2\)


	
特殊权限：
passwd :s 

SUID:运行某程序时；相应进程的属主是程序文件自身的属主，而不是启动者
	chmod u+s file 
		如果file本身有执行权限，则suid显示为s 没有就显示为S
		u-s
		这种使用与直接修改命令的比如cat、passwd等
		
SGID:运行某程序时；相应进程的属组是程序文件自身的属组，而不是启动者所属的基本组
	chmod g+s file
		  g-s 
	场景：开发团队,有三个用户，分别在自己的目录下，都可以创建文件，可以互相编辑对方的文件

sticky ：每个人都可以创建文件，删除自己的文件，但不能删除别人的文件
	是对目录而言的
	chmod o+t
	chmod o-t  

给目录修改基本组信息
chown -R :team path ==为啥加: 不加:就代表的是改的是属主
	


chmod 1777 /test
1对应的是001  001指上面的SUID SGID Sticky
775对应的是rwx
------------------------------------
上面说的场景：
	suid:其他用户调用某个文件或者命令，当前进程就会以该用户的权限执行，如果想要其他用户调用或者执行时，以改文件的属主来执行，就需要chmod u+s file 来使
	该进程以文件的属主来执行
	
	sgid：
		一个团队，可以在相同目录下创建文件，其他成员都可以读写操作。这种情况下我们想到的是：一个用户创建的文件属主是自己，属组也是自己，那么需要将所有的用户加到同一个组里面
		这个组有这个rw权限就可以，但是，用户创建后，怎么能自动继承当前目录的权限呢？
		mkdir /www/zpl
		groupadd team
		chgrp g+w /www/zpl //给路径添加组的写权限
		usermod -a -G team user1 //给user1追加组team -a 追加的意思
		usermod -a -G team user2
		这时候可以往该目录中添加文件 touch user1.html 	但该文件的属组却是自己
		
		chmod g+s /www/zpl 这时，就可以创建文件后文件的属组是目录的属组
		
		这样成员就可以互相修改读取文件了
		
		
	但是这时候我不想让该文件被非属主删除，因为有写权限，所以可以被删除，要达到效果，需要：
	sticky
		对目录做sticky操作
		chmod o+t 这样就不能删除了，只有属主才可以删除
		
==============================================================

tom:创建一个文件也希望jerry能够查看
tom:
	属主：tom 属组：tom
这时：jerry的权限在 other上。这时我们可以在other上有读权限，但是，其他非jerry也有了读权限了，但是我们只想jerry看到
怎么做呢？

facl 的使用：File Access Control List 文件系统访问控制列表
利用文件扩展属性，来保存额外的访问控制权限

facl :
getfacl file
setfacl 
		-m 设定
			u:UID/USER:perm  file 设定某用户什么权限  如：setfacl -m u:jerry:rw file 
			g:GID/GROUP:perm file
		-x 取消
			setfacl -x u:jerry file
		-b  setfacl -b  file 删除所有的
			
权限的判断
	Owner-->GROUP---Other
	Owner --->facl,user--->GROUP--->facl,group-->Other

------------------------------------------------------------------------------------------
whoami :显示当前登录到系统的有效用户信息

who 登录到系统的用户以及登录到系统的终端
	每隔5s钟，查看用户zpl是否已经登录，登录就显示用户以及登录，否则就一直每隔五秒钟查看下
	sleep
	
	#!/bin/bash
	who |grep "zpl" &>/dev/null
	islogin=$?
	while [ $islogin -ne 0 ];do
		echo "`date` ,zpl没有登录"
		sleep 5
		who |grep "zl" &>/dev/null
		islogin=$?
	done
	echo "zpl 登录成功"
	
	
w ：显示谁登录了，并显示干啥事儿呢
last :查看登录日志、显示、/var/log/wtmp 文件包含用户登录日志和系统重启日志
	last -n 只显示最近几次的日志
	
lastb :显示用户错误登录的日志，没有登录成功的 /var/log/btmp 文件

lastlog :显示每一个用户最近的登录信息，
	lastlog -u username 指定用户名

basename  /www/zpl/a.html: --->a.html 
basename /www/zpl/ --->zpl


mail 用来查看邮件，查看后会放到用户家目录下的mbox文件下


hostname:显示当前主机名的
	hostname name 可以修改主机名,只是修改当前shell环境的
	$HOSTNAME :Linux环境的主机名
	
----------------------
系统内置变量：RANDOM
生成随机数：
RANDOM: 0-32768之间的数

随机数生成器： /dev/random
			   /dev/urandom

echo -n $RANDOM 不要追加换行操作 -n 


多分支的选择结构

case语句
case SWITCH in
value1)
	statement1
	......
	;;  			必须双分号结束
value2)
	statement 
	........
	;;
*)
	statement
	........
	;;
esac

value是当做字符来比较的
	a-z
	A-Z
	0-9
	[abc]  表示abc中的某一个
	
压缩归档命令
gzip  .gz
zip   .zip
bzip2  .bz2 
xz     .xz

gzip
	gzip /PATH/TO/file :压缩完成后会删除源文件
		-d ：解压缩
		-#：1-9 指定压缩比
gunzip /PATH/TO/file.gz ==gzip -d /PATH/TO/file.gz 解压缩
zcat /PATH/TO/file.gz 不用解压缩就可以查看.gz文件的文本文件内容

bzip2
	bzip2 比gzip有更大的压缩比工具，压缩后会删除源文件
	bzip2 /PATH/TO/file 	
		-d 解压缩
		-# 1-9：压缩比
	bzip2 -k /PATH/TO/file 压缩时保留源文件
bunzip2 /PATH/TO/file.bz2 ==bzip2 -d /PATH/TO/file.bz2 解压缩
bzcat 不解压可以直接查看

安装xz命令时，请确定在路径：/etc/yum.repos.d/下的 server.repo
如果没有就必须使用命令wget ftp://172.16.0.1/pub/gls/server.repo
并且移动至到这个目录下
xz /PATH/TO/file -->file.xz
unxz /PATH/TO/file.xz 解压缩=xz -d /PATH/TO/file.xz

zip：压缩比不大，但是可以压缩目录


zip 压缩后的名.zip  要压缩的目录或者文件 压缩后不会删除源文件
	zip filename.zip /path/或者文件。。。
	zip filename.zip  /path/ 就会只压缩目录，但是里面文件没有压缩进去
	zip filename.zip  /path/* 所有文件都会压缩进去
	解压缩
	unzip filename.zip
	
tar 只归档不压缩的工具
	-c :创建归档文件
	-f file.tar: 操作的归档文件
	-x: 还原归档
	--xattrs :归档的同时保留其扩展属性信息
	
	tar -cf test.tar test*.txt  归档
	tar -xf test.tar 展开归档。类似解压缩
	tar -tf test.tar 不用解归档可以查看归档了哪些文件
	
	归档后可以再使用gzip bzip2 xz zip 进行压缩
	
	tar可以直接调用这些压缩 解压缩的时候可以省略-z -j -J 可直接使用-xf ,
	他可以自己判断并解压缩
	tar -zcf test.tar.gz files...归档后调用gzip压缩
	tar -zxf test.tar.gz 先调用gzip先解压缩后展开归档 -z 可以省略
	
	tar -jcf  test.tar.bz2  files ...调用bzip2 压缩
	tar -jxf  test.tar.bz2  
	tar -Jcf 调用xz压缩
	tar -Jxf 调用xz解压缩


cpio:做成归档或者展开归档，比tar更老，有tar不具备的能力


练习：从键盘让用户输入几个文件，脚本能够将此几个文件归档压缩

read name 会从键盘获取用户输入，与用户交互

read -p "描述提示信息" A B 
	-p "PROMPT":给出提示的
	-t 30:三十秒没有输入就会过期，并接着往下走
指定可以输入多少个参数？可以吗？


脚本编程：
	顺序结构
	选择结构
		if 
		case
	循环结构
		for 
		while
		until

	while 循环 ，使用循环次数未知的场景
	语法：
		while condition;do
			statement
			.......
		done
		
		
	1-100之和
	
	#!/bin/bash
	declare -i I=1
	declare -i sum=0
	while [ $I -le 100];do
		let sum+=$I
		let I++
	done
		

echo -e "\033[31mHello\033[0m,world" 3是前景色 后面是颜色值1-7
echo -e "\033[41mHello\033[0m ,world" 4是背景色 后面是颜色值1-7
echo -e "\033[1mHello\033[0m world" 一位数字时，代表字体的大小粗细
范围是\033[1m开始-到\033[0m结束


----------------------磁盘分区暂时不说----------------
看了一遍没看懂，以后再看吧
概念性东西太多了不易理解

------------------------------------------------------
		
		
	
	
















	
	
	











